# Socket 通信

在应用层，我们应该如何使用 socket 的接口来进行通信。

socket 接口大多数情况下操作的是传输层，更底层的协议不用它来操心，这就是分层的好处。

## TCP vs UDP

这两个协议的区别是什么呢？通常的答案是下面这样的。

- TCP 是面向连接的，UDP 是面向无连接的。
- TCP 提供可靠交付，无差错、不丢失、不重复、并且按序到达；UDP 不提供可靠交付，不保证不丢失，不保证按顺序到达。
- TCP 是面向字节流的，发送时发的是一个流，没头没尾；UDP 是面向数据报的，一个一个地发送。
- TCP 是可以提供流量控制和拥塞控制的，既防止对端被压垮，也防止网络被压垮。

这样说没问题，但是没有达到本质，让人产生错觉。

- 什么是所谓的连接？
- IP 层都是一个包一个包地发送，TCP 怎么就变成流了？

所谓的**建立连接**，其实是在客户端和服务端建立的数据结构来维护双方交互的状态。

所谓的**连接**，就是两端数据结构状态的协同，两边的状态能够对得上。符合 TCP 协议的规则，就认为连接存在；两面状态对不上，连接就算断了。

> “连接”两个字让人误以为功夫在通路，其实功夫在两端。

当然，无论是用 socket 操作 TCP，还是 UDP，我们首先都要调用 socket 函数。

```c
ini socket(int domain, int type, int protocol)
```

socket 函数用于创建一个唯一标识的文件描述符，socket 函数有三个参数：

- domain：表示用什么 IP 协议，AF_INET 表示 IPv4，AF_INET6 表示 IPv6。
- type：表示 socket 类型，SOCK_STREAM 是 TCP，SOCK_DGRAM 是 UDP。
- protocol：表示协议。

通信结束后，我们还要像关闭文件一样，关闭 socket。

## 针对 TCP 应该如何编程？

- 服务端和客户端都调用 socket，得到文件描述符。
- 服务端调用 bind 绑定端口，然后 listen 进行监听。
- 服务端调用 accept，等待客户端连接，阻塞住。
- 客户端调用 connect，连接服务端，在这里进行的三次握手，是在内核完成的，应用层不需要参与。
- 服务端 accept 返回用于传输的 socket 的文件描述符。
- 客户端调用 write 写入数据。
- 服务端调用 read 读取数据。

> 监听的 socket 和真正用来传送数据的 socket，是两个 socket，一个叫作监听 socket，一个叫作已连接 socket。
