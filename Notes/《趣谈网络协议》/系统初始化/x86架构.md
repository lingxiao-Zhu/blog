# x86 架构

## 计算机的工作模式是什么样的？

最核心的是 **CPU**，计算机的大脑，CPU 和其他设备连接，要靠**总线**，就是主板上密密麻麻的集成电路。
单靠 CPU 无法完成计算任务，需要将很多复杂的计算任务的中间结果保存下来，需要依赖**内存**

> CPU 和内存是完成计算任务的核心组件，所以这里我们重点介绍一下 CPU 和内存是如何配合工作的。

### CPU

CPU 其实也不是单纯的一块，它包括三个部分，运算单元、数据单元和控制单元。

#### 运算单元

只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。

#### 数据单元

运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。

#### 控制单元

可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。

那 CPU 怎么执行这些程序，操作这些数据，产生一些结果，并写入回内存呢？

控制单元有一个**指令指针寄存器**，一条指令通常包含**操作码**和**操作数**，操作码规定指令的功能，操作数指明该条指令操作相关的数据，要执行这条指令，就要把第一部分交给运算单元，第二部分交给数据单元。

### 总线

CPU 和内存来来回回传数据，靠的都是总线。分为**地址总线**和**数据总线**。

#### 地址总线

地址总线传输数据在内存中的位置，地址总线的位数决定了能访问地址的范围。

#### 数据总线

数据总线传输真正的数据，位数决定了一次能拿多少数据进来。

## x86 架构

CPU 中总线位数没有标准的话，操作系统很难办，无法实现通用的运算逻辑。英特尔成为了行业的开放事实标准。由于这个系列开端于 8086，因此称为 x86 架构。

### 数据单元

8086 处理器内部有 8 个 16 位的通用寄存器，也就是 CPU 中的数据单元。分别是 AX、BX、CX、DX、SP、BP、SI、DI。

### 控制单元

- IP 寄存器：指令指针寄存器，指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中加载到 CPU 的指令队列中，然后交给运行单元执行。

> 如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有 4 个 16 位的段寄存器，分别是 CS、DS、SS、ES。

- CS：代码段寄存器，通过它可以找到代码在内存中的位置。
- DS：数据段的寄存器，通过它可以找到数据在内存中的位置。
- SS：栈寄存器，凡是和函数调用相关的操作，都和栈紧密相关。

如果运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器中，应该如何加载呢？对于一个段，有一个起始的地址，而段内的具体位置，我们称为**偏移量（Offset）**

在 CS 和 DS 中都存放着一个段的起始地址。代码段的偏移量在 IP 寄存器中，数据段的偏移量会放在通用寄存器中。

这时候问题来了，CS 和 DS 都是 16 位的，也就是说，起始地址都是 16 位的，IP 寄存器和通用寄存器都是 16 位的，偏移量也是 16 位的，但是 8086 的地址总线地址是 20 位。怎么凑够这 20 位呢？方法就是“起始地址 \*16+ 偏移量”，也就是把 CS 和 DS 中的值左移 4 位，变成 20 位的，加上 16 位的偏移量，这样就可以得到最终 20 位的数据地址。

> 对于只有 20 位地址总线的 8086 来讲，能够区分出的地址也就 2^20=1M，超过这个空间就访问不到了。

## 32 位处理器

在 32 位处理器中，有 32 根地址总线，可以访问 2^32=4G 的内存。

对**段寄存器**进行了不兼容处理，CS、SS、DS、ES 仍然是 16 位，但是不再是段的起始位置。段的起始位置放在内存的某个地方，这个地方是一个表格，表格中一项一项是**段描述符**。这里面才是真正的段的起始位置，而段寄存器保存的是表格中的哪一项，称为**选择子**。

> 将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。

## 总结

CPU 通过总线和内存进行数据读取，执行一段程序时，控制单元通过**段寄存器**记录代码段和数据段的内存起始位置，实现进程的切换。通过**指令指针寄存器**保存下一条指令段偏移量。指令分两部分，一部分是做什么操作，例如是加法还是位移；一部分是操作哪些数据。要执行这条指令，就要把第一部分交给运算单元，第二部分交给数据单元。数据单元根据数据的地址，从数据段里读到数据寄存器里，就可以参与运算了。运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。最终，会有指令将数据写回内存中的数据段。
