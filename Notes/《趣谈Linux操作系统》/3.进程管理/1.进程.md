# 进程

## ELF

在 Linux 下面，二进制的程序也要有严格的格式，这个格式我们称为 ELF（Executeable and Linkable Format，可执行与可链接格式）

> 这个格式可以根据编译的结果不同，分为不同的格式。

### 第一种 可重定位文件

```c
gcc -c -fPIC process.c
gcc -c -fPIC createprocess.c
```

在编译的时候，先做**预处理工作**，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o 文件

为啥叫可重定位？

比如说，调用一个函数，其实就是跳到这个函数所在的代码位置执行；再比如修改一个全局变量，也是要到变量的位置那里去修改。

但是现在这个时候，还是.o 文件，不是一个可以直接运行的程序，这里面只是部分代码片段。编译好的代码和变量，将来加载到内存里面的时候，都是要加载到一定位置的。

要想让 create_process 这个函数作为库文件被重用，不能以.o 的形式存在，而是要形成库文件，最简单的类型是静态链接库.a 文件（Archives），仅仅将一系列对象文件（.o）归档为一个文件，使用命令 ar 创建。

当有程序要使用这个静态连接库的时候，会将.o 文件提取出来，链接到程序中。这个链接的过程，重定位就起作用了，代码合并为可执行文件，就知道具体调用的位置了。

### 第二种 可执行文件

形成的二进制文件叫可执行文件，是 ELF 的第二种格式。

这个文件是多个.o 文件合并的，已经是马上就可以加载到内存里面执行的文件了，因而被分成了需要加载到内存里面的代码段、数据段和不需要加载到内存里面的部分。

> 静态链接库一旦链接进去，代码和变量的 section 都合并了，因而程序运行的时候，就不依赖于这个库是否存在。但是这样有一个缺点，就是相同的代码段，如果被多个程序使用的话，在内存里面就有多份，而且一旦静态链接库更新了，如果二进制执行文件不重新编译，也不随着更新。

比如 a.o，b.o 都依赖 lib.a 中的 c.o，那么都合并到 a.o 和 b.o 中去，c.o 在内存存在两份。

因而就出现了另一种，**动态链接库（Shared Libraries）**，不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享。

### 第三种 共享对象文件

动态链接库，就是 ELF 的第三种类型。

当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。

当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。

## 运行程序为进程

知道了 ELF 这个格式，这个时候它还是个程序，那怎么把这个文件加载到内存里面呢？

原理是 exec 这个系统调用最终调用的 load_elf_binary。

## 进程树

既然所有的进程都是从父进程 fork 过来的，那总归有一个祖宗进程，这就是咱们系统启动的 init 进程。
