# 系统调用

## 创建进程

创建进程的系统调用叫 fork。

在 Linux 里，要创建一个新的进程（子进程），需要一个老的进程（父进程）调用 fork 来实现。

当父进程调用 fork 创建子进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝一份，甚至连程序代码也拷贝过来。

如果不进行特殊的处理，父进程和子进程都按相同的程序代码进行下去，没有意义。所以对于 fork 系统调用的返回值，如果当初进程是子进程，就返回 0；如果是父进程，就返回子进程的进程号。这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支（fork）了。

有个系统调用 waitpid，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

## 内存管理

每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。

对于进程的内存空间来讲，放程序代码的这部分，我们称为代码段（Code Segment）。

对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为数据段（Data Segment）

> 其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；也有动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（Heap）。

系统不会事先给进程分配内存，进程需要使用时，调用系统调用请求分配。这里我们介绍两个在堆里面分配内存的系统调用，brk 和 mmap。

- brk：当分配的内存数量比较小的时候，使用 brk，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了
- mmap：当分配的内存数量比较大的时候，使用 mmap，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

## 文件管理

对于文件的操作，下面这六个系统调用是最重要的：

- 对于已经有的文件，可以使用 open 打开这个文件，close 关闭这个文件；
- 对于没有的文件，可以使用 creat 创建文件；
- 打开文件以后，可以使用 lseek 跳到文件的某个位置；
- 可以对文件的内容进行读写，读的系统调用是 read，写是 write。

> Linux 里有一个特点，一切皆文件。

- 启动一个进程，需要一个程序文件，这是一个二进制文件。
- 启动的时候，要加载一些配置文件，例如 yml、properties 等，这是文本文件；
- 启动之后会打印一些日志，如果写到硬盘上，也是文本文件。
- 但是如果我想把日志打印到交互控制台上，在命令行上唰唰地打印出来，这其实也是一个文件，是标准输出 stdout 文件。
- 这个进程的输出可以作为另一个进程的输入，这种方式称为管道，管道也是一个文件。
- 进程可以通过网络和其他进程进行通信，建立的 Socket，也是一个文件。
- 进程需要访问外部设备，设备也是一个文件。
- 文件都被存储在文件夹里面，其实文件夹也是一个文件。
- 进程运行起来，要想看到进程运行的情况，会在 /proc 下面有对应的进程号，还是一系列文件。

每个文件，Linux 都会分配一个文件描述符（File Descriptor），这是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。

## 信号处理

进程遇到异常情况，需要发出一个信号。经常遇到的信号：

- 在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；
- 非法访问内存
- 硬件故障
- 用户进程通过 kill 函数

对于一些不严重的信号，可以忽略，但是像 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的，可以执行对于该信号的默认动作。每种信号都定义了默认的动作，例如硬件故障，默认终止；也可以提供信号处理函数，可以通过 sigaction 系统调用，注册一个信号处理函数。

## 进程间通信

### 消息队列

用于不需要一段很长的数据。

这个消息队列是在内核里的，我们可以通过 msgget 创建一个新的队列，msgsnd 将消息发送到消息队列，而消息接收方可以使用 msgrcv 从队列中取消息。

### 共享内存

需要交互的信息比较大的时候。

可以通过 shmget 创建一个共享内存块，通过 shmat 将共享内存映射到自己的内存空间，然后就可以读写了。

但是两个进程同时访问一个数据，会存在**竞争**，这就需要有一种方式，让不同的人能够排他地访问，这就是信号量的机制 Semaphore。

对于只允许一个人访问的需求，我们可以将信号量设为 1。当一个人要访问的时候，先调用 sem_wait。如果这时候没有人访问，则占用这个信号量，他就可以开始访问了。如果这个时候另一个人要访问，也会调用 sem_wait。由于前一个人已经在访问了，所以后面这个人就必须等待上一个人访问完之后才能访问。当上一个人访问完毕后，会调用 sem_post 将信号量释放，于是下一个人等待结束，可以访问这个资源了。

## 网络通信

不同机器的通过网络相互通信，要遵循相同的网络协议，也即 TCP/IP 网络协议栈。Linux 内核里有对于网络协议栈的实现。

你可以想象成弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个 Socket。

我们可以通过 Socket 系统调用建立一个 Socket。Socket 也是一个文件，也有一个文件描述符，也可以通过读写函数进行通信。

## 常见系统调用

```c
#define __NR_restart_syscall    0
#define __NR_exit      1
#define __NR_fork      2
#define __NR_read      3
#define __NR_write      4
#define __NR_open      5
#define __NR_close      6
#define __NR_waitpid      7
#define __NR_creat      8
......

```

你会发现这些系统调用和我们平时用的不太一样，是因为我们没有直接调用，而是使用了中介 Glibc。

Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。

每个特定的系统调用对应了至少一个 Glibc 封装的库函数，比如说，系统提供的打开文件系统调用 sys_open 对应的是 Glibc 中的 open 函数。

有时候，Glibc 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用。

也有时候，多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。
