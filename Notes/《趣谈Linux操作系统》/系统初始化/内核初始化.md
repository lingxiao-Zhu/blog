# 内核初始化

## init_task

创建 0 号进程

它是系统创建的第一个进程，这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个。

## trap_init

设置很多中断门。

中断是改变处理器执行指令顺序的一种事件。引入中断机制后，使 CPU 可以与其他设备并行工作，提高 CPU 的利用率，支持系统异步。

> 系统调用也是通过发送中断的方式进行的

## mm_init

初始化内存管理模块

## sched_init

初始化调度模块。

## vfs_caches_init

初始化基于内存的文件系统 rootfs

文件系统是我们的项目资料库，为了兼容各种各样的文件系统，我们需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的接口，这个抽象层就是 VFS（Virtual File System），虚拟文件系统。

## rest_init

其他方面的初始化。

### 初始化 1 号进程

用 kernel_thread(kernel_init, NULL, CLONE_FS) 创建第二个进程，这个是 1 号进程。

1 号进程对于操作系统来讲，有“划时代”的意义。因为它将运行一个用户进程，有了用户进程后，需要把资源划分为核心资源和非核心资源。

x86 提供了分层第权限机制，从内往外依次：

- Ring0：内核态。能访问关键资源
- Ring1
- Ring2
- Ring3：用户态，普通的程序代码

当处于用户态的代码想要执行更高权限的指令，这种行为是被禁止的，要防止他们为所欲为。

那么如果用户态想要访问核心资源怎么办？

trap_init 设置了很多中断门，用于系统调用，用户态代码请求就行了，不用管后面发生了什么，做完了返回结果就行。

当一个用户态的程序运行到一半，要访问一个核心资源，例如访问网卡发一个网络包，就需要暂停当前的运行，调用系统调用，接下来就轮到内核中的代码运行了。

> 程序运行一般暂停后，需要把当前的情况保存下来。所以，要把暂停那一刻的 CPU 的寄存器的值全部暂存到一个地方。

**用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，然后接着运行**。

1 号进程创建完后，回去执行文件系统的 init 文件，接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。

形成了用户态所有进程的祖先。

### 创建 2 号进程

负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。

> 从用户态来看，创建进程其实就是立项，也就是启动一个项目。这个项目包含很多资源，例如会议室、资料库等。这些东西都属于这个项目，但是这个项目需要人去执行。有多个人并行执行不同的部分，这就叫多线程（Multithreading）。如果只有一个人，那它就是这个项目的主线程。
