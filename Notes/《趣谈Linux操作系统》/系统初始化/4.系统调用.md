# 系统调用

系统调用（system call）是指操作系统提供给程序调用的接口。

> 操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用（system call)的接口呈现给用户。系统调用把应用程序的请求传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序。

把系统调用比做办事大厅，用户态比做客户。

直接去办事大厅还是不够方便。Linux 还提供了 glibc 这个中介。它更熟悉系统调用的细节，并且可以封装成更加友好的接口直接用。

## glibc 对系统调用的封装

在 glibc 的源代码中，有个文件 syscalls.list，里面列着所有 glibc 的函数对应的系统调用，就像下面这个样子：

```c
# File name Caller Syscall name Args Strong name Weak names
open - open Ci:siv __libc_open __open open

#define DO_CALL(syscall_name, args) \
    PUSHARGS_##args \
    DOARGS_##args \
    movl $SYS_ify (syscall_name), %eax; \
    ENTER_KERNEL \
    POPARGS_##args

ENTER_KERNEL：define ENTER_KERNEL int $0x80

```

int 就是 interrupt，也就是“中断”的意思，int $0x80 就是触发一个软中断，通过它就可以陷入（trap）内核。

在内核启动的时候，还记得有一个 trap_init()，其中有这样的代码：

```c
set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32);
```

通过 push 和 SAVE_ALL 将当前用户态的寄存器，保存在 py_regs 结构里面：

```c

ENTRY(entry_INT80_32)
        ASM_CLAC
        pushl   %eax                    /* pt_regs->orig_ax */
        SAVE_ALL pt_regs_ax=$-ENOSYS    /* save rest */
        movl    %esp, %eax
        call    do_syscall_32_irqs_on
.Lsyscall_32_done:
......
.Lirq_return:
  INTERRUPT_RETURN
```
